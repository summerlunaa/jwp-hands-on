# HTTP 완벽 가이드와 구구의 강의로 공부한 HTTP 캐시

## 캐시란?

웹 캐시는 자주 쓰이는 문서의 사본을 자동으로 보관하는 HTTP 장치입니다. 캐시된 로컬 사본이 존재한다면 문서는 원래 서버가 아니라 캐시에서 제공됩니다.

### 캐시의 장점

- 불필요한 데이터 전송을 줄여 네트워크 요금으로 인한 비용을 줄여줌.
- 네트워크 병목을 줄여 대역폭을 늘리지 않아도 속도 향상 가능.
- 원 서버에 대한 요청을 줄여 서버 부하 감소.
- 거리로 인한 지연도 감소시킴.

### 재검사(Revalidation)

원 서버의 콘텐츠는 언제든지 변경될 수 있습니다. 따라서 캐시에 저장된 사본이 최신인지 확인할 필요가 있습니다. 이 과정을 재검사라 부릅니다.

재검사를 효과적으로 하기 위해 HTTP에는 서버에서 전체 객체를 가져오지 않고도 콘텐츠가 최신인지 빠르게 검사할 수 있는 요청이 존재합니다. 재검사 요청시 콘텐츠가 변경되지 않았다면 `304 Not Modified` 응답을 보냅니다. 이를 `재검사 적중` 혹은 `느린 적중`이라 부릅니다. cache hit 보다는 느리지만 cache miss 보다는 빠릅니다.

### If-Modified-Since

서버에게 보내는 GET 요청에 추가할 수 있는 헤더입니다. 이 헤더를 추가하면 캐시된 시간 이후에 변경된 경우에만 사본을 보내달라는 의미가 됩니다. 이 요청이 서버에 도착했을 때 일어날 수 있는 세 가지 경우를 알아봅시다.

- 재검사 적중
    - 서버는 클라이언트에게 `304 Not Modified` 응답을 보낸다.
- 재검사 부적중
    - 서버는 콘텐츠와 함께 `200 OK` 응답을 보낸다.
- 객체 삭제
    - 서버는 `404 Not Found` 응답을 보내며 캐시는 사본을 삭제한다.

### 적중률

적중률은 높을 수록 좋지만 예측하기는 힘듭니다. 오늘날 적중률이 40%면 웹 캐시로 괜찮은 편이라고 합니다. `바이트 적중률`은 캐시를 통해 제공된 모든 바이트의 비율을 표현합니다. 바이트 단위 적중률이 100%라는 것은 모든 바이트가 캐시에 있으며 어떤 트래픽도 인터넷으로 나가지 않았다는 것을 의미합니다. 문서 적중률이 전체 지연 시간을 줄인다면 바이트 적중률은 대역폭을 절약합니다.

## 캐시 토폴로지

### 개인 전용 캐시 VS 공용 캐시

개인 전용 캐시는 한 명에게만 할당된 캐시입니다. 보통 작고 저렴한 편이며 웹브라우저가 개인 전용 캐시를 내장하고 있습니다.

공용 캐시는 캐시 프록시 서버 혹은 프록시 캐시라고 불리기도 합니다. 프록시 캐시는 로컬 캐시에서 문서를 제공하거나 사용자의 입장에서 서버에 접근합니다.

개인 전용 캐시들은 각각 네트워크를 거쳐 서버에 접근합니다. 반면 공유된 캐시는 자주 찾는 객체를 한 번만 가져와 모든 요청에 대해 사본을 제공하기 때문에 불필요한 트래픽을 더 많이 줄일 수 있습니다.

![공유된 공용 캐시는 네트워크 트래픽을 줄인다](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/223d58a3-c8d5-4d15-babc-fd93bb0020aa/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20220902%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20220902T064815Z&X-Amz-Expires=86400&X-Amz-Signature=24dfabd3c4352d966d8e8e8a5b63ddba7b169d9db14d94f83fd315d107715956&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Untitled.png%22&x-id=GetObject)

## 캐시 처리 단계

1. 요청 받기 - 캐시가 네트워크로부터 도착한 요청 메시지를 읽는다.
2. 파싱 - 캐시는 미시지를 파싱하여 URL와 헤더를 추출한다.
3. 검색 - 캐시는 로컬 복사본이 있는지 검사하고 사본이 없다면 사본을 받아와 로컬에 저장한다.
4. 신선도 검사 - 캐시는 복사본이 최신인지 검사하고 최신이 아니라면 변경사항이 있는지 서버에 물어본다.
5. 응답 생성 - 캐시는 새로운 헤더와 캐시된 본문으로 응답 메시지를 만든다.
6. 발송 - 캐시는 네트워크를 통해 응답을 클라이언트에게 돌려준다.

## 캐시 사본을 최신으로 유지하기

사본 문서가 만료되면 캐시는 반드시 서버에 문서가 변경되었는지 검사해야 합니다. 이것을 서버 재검사라 부릅니다. 

만약 변경이 있다면 최신본을 얻어와 캐시에 다시 저장해야 합니다. 변경되지 않았다면 캐시는 새 만료일을 포함한 새 헤더들만 가져와서 캐시 안의 헤더를 갱신합니다.

### 문서 유효 기간 지정

- `Cache-Control: max-age`
  - `Cache-Control: max-age=484200`
  - 문서의 최대 나이. 문서가 처음 생성된 이후부터 최신이 아니라고 간주될 때까지 경과한 시간의 최댓값(초)이다.
- `Expires`
  - `Expires: Fri, 05 Jul 2022, 05:00:00 GMT`
  - 절대 유효기간을 명시한다. 잘 사용하지 않는다.

### 조건부 메서드와 재검사

HTTP 조건부 메서드는 재검사를 효율적으로 만듭니다. `조건부 GET` 요청을 보내면 서버는 캐시가 가진 문서가 변경이 있는 경우에만 객체 본문을 보낸다.

- `If-Modified-Since: <date>`
  - 만약 문서가 주어진 날짜 이후로 수정되었다면 요청 메서드를 수행한다. 캐시된 버전으로부터 콘텐츠가 변경된 경우에만 콘텐츠를 가져오기 위해 `Last-Modified` 서버 응답 헤더와 함께 사용한다.
- `If-None-Match: <tags>`
  - 문서에 대한 일련번호와 같이 동작하는 태그(`ETag`)를 사용한다. 캐시된 캐그가 서버의 문서 태그와 다를 때만 요청을 처리한다.

### 휴리스틱

만약 응답에 문서 유효 기간을 지정하지 않았다면 캐시는 경험적인 방법(휴리스틱)으로 max-age를 계산합니다. 

### Cache-Control

- `no-cache`
  - 캐시된 리소스는 무조건 재검사를 해야한다.
- `no-stroe`
  - 캐시에 저장 자체를 하지 않는다. 하지만 브라우저가 가진 이점을 활용하지 못할 수도 있기 때문에 권장하지 않는다. 

## 캐시 무효화 (Cache Busting)

정적 파일 등은 잘 변경되지 않기 때문에 캐시에 오래 저장할 수 있게 URL을 다르게 가져가는 전략을 사용합니다. (캐시 key로 url을 가져가기 때문에 url이 바뀌면 새 파일로 교체를 합니다.)

캐시 유효 기간을 1년 정도로 길게 가져가고 배포 시 URL을 변경하여 배포합니다.

### 캐시 무효화 방법

1. version in filename (`bundle.v123.js`)
2. version in query (`bundle.js?v=123`)
3. hash in filename (`bundle.YsAIAAA-QG23DFAGAGVVR234.js`)
4. hash in query (`bundle.js?v=YsAIAAA-QG23DFAGAGVVR234`)

---
### 참고 자료
- [https://gunju-ko.github.io/spring/spring-boot/2018/06/16/SpringBootCompression.html](https://gunju-ko.github.io/spring/spring-boot/2018/06/16/SpringBootCompression.html)
- [https://jo5ham.tistory.com/34](https://jo5ham.tistory.com/34)
